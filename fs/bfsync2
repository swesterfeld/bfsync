#!/usr/bin/env python

# bfsync: Big File synchronization based on Git

# Copyright (C) 2011 Stefan Westerfeld
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import sys
import os
import subprocess
import hashlib
import pickle
import traceback
import time
import tempfile
import CfgParser
import HashCache
import StatusLine

def find_bfsync_dir():
  old_cwd = os.getcwd()
  dir = old_cwd
  while True:
    try:
      test_dir = os.path.join (dir, ".bfsync")
      os.chdir (test_dir)
      os.chdir (old_cwd)
      return test_dir
    except:
      pass
    # try parent directory
    newdir = os.path.dirname (dir)
    if newdir == dir:
      # no more parent
      raise Exception ("can not find .bfsync directory")
    dir = newdir

def compute_size (filename):
  return os.stat (filename).st_size

def format_size (size, total_size):
  unit_str = [ "B", "KB", "MB", "GB", "TB" ]
  unit = 0
  while (total_size > 10000) and (unit + 1 < len (unit_str)):
    size = (size + 512) / 1024
    total_size = (total_size + 512) / 1024
    unit += 1
  return "%d/%d %s" % (size, total_size, unit_str[unit])

def format_rate (bytes_per_sec):
  unit_str = [ "B/s", "KB/s", "MB/s", "GB/s", "TB/s" ]
  unit = 0
  while (bytes_per_sec > 10000) and (unit + 1 < len (unit_str)):
    bytes_per_sec /= 1024
    unit += 1
  return "%.1f %s" % (bytes_per_sec, unit_str[unit])

def format_time (sec):
  sec = int (sec)
  if (sec < 3600):
    return "%d:%02d" % (sec / 60, sec % 60)
  else:
    return "%d:%02d:%02d" % (sec / 3600, (sec / 60) % 60, sec % 60)

def hash_all (filenames):
  # compute total size of all files
  bytes_total = 0
  for filename in filenames:
    bytes_total += compute_size (filename)
  # hash data
  bytes_done = 0
  file_number = 0
  start_time = time.time()
  status_line.set_op ("HASH")
  for filename in filenames:
    file = open (filename, "r")
    file_number += 1
    hash = hashlib.sha1()
    eof = False
    while not eof:
      data = file.read (256 * 1024)
      if data == "":
        eof = True
      else:
        hash.update (data)
        bytes_done += len (data)
        elapsed_time = max (time.time() - start_time, 1)
        bytes_per_sec = max (bytes_done / elapsed_time, 1)
        eta = int ((bytes_total - bytes_done) / bytes_per_sec)
        status_line.update ("file %d/%d    %s    %.1f%%   %s   ETA: %s" % (
          file_number, len (filenames),
          format_size (bytes_done, bytes_total),
          bytes_done * 100.0 / max (bytes_total, 1),
          format_rate (bytes_per_sec),
          format_time (eta)
        ))
    file.close()
  return

def compute_mode (filename):
  return os.stat (filename).st_mode

def commit_msg_ok (filename):
  file = open (filename, "r")
  result = False
  for line in file:
    line = line.strip()
    if len (line):
      if line[0] == "#":
        pass
      else:
        result = True
  file.close()
  return result

def mkdir_recursive (dir):
  if os.path.exists (dir) and os.path.isdir (dir):
    return
  else:
    try:
      os.makedirs (dir)
      if os.path.exists (dir) and os.path.isdir (dir):
        return
    except:
      pass
  raise Exception ("can't create directory %s\n" % dir)

def cmd_commit():
  if len (args) != 1:
    raise Exception ("commit requires mount-point as argument")

  os.chdir (args[0])
  bfsync_dir = find_bfsync_dir()
  bfsync_info = CfgParser.CfgParser ((bfsync_dir + "/info"),
  [
  ],
  [
    "repo-path",
    "mount-point"
  ])

  repo_path = bfsync_info.get ("repo-path")
  if len (repo_path) != 1:
    raise Exception ("bad repo path")
  repo_path = repo_path[0]

  mount_point = bfsync_info.get ("mount-point")
  if len (mount_point) != 1:
    raise Exception ("bad mount point")
  mount_point = mount_point[0]

  # chdir to repo_path to allow unmount
  os.chdir (repo_path)
  if subprocess.call (["fusermount", "-u", mount_point]) != 0:
    raise Exception ("umount failed")

  os.chdir (os.path.join (repo_path, "new"))
  file_list = []
  for dir, dirs, files in os.walk ("."):
    for file in files:
      file_list += [ os.path.join (dir, file) ]

  if len (file_list) == 0:
    raise Exception ("no changes to commit")

  hash_all (file_list)
  (fd,name) = tempfile.mkstemp (prefix = "bfsync_commit_")
  f = os.fdopen (fd, "w")
  f.write("\n")
  for filename in file_list:
    f.write ("# add %s\n" % filename)
  f.close()
  os.system ("vim %s" % name)
  if not commit_msg_ok (name):
    raise Exception ("commit message is empty")

  for filename in file_list:
    try:
      new_file = os.path.join (repo_path, "new", filename)
      hash = hash_cache.compute_hash (new_file)
      size = compute_size (new_file)
      mode = compute_mode (new_file)
    except Exception, ex:
      raise

    git_file = os.path.join (repo_path, "git/files", filename)
    mkdir_recursive (os.path.dirname (git_file))
    try:
      gf = open (git_file, "w")
      gf.write ("hash = %s\n" % hash)
      gf.write ("size = %d\n" % size)
      gf.write ("mode = %o\n" % mode)
      gf.close()
    except Exception, ex:
      raise
    os.chdir (os.path.join (repo_path, "git"))
    if subprocess.call (["git", "add", git_file]) != 0:
      raise Exception ("cannot git add file %s\n" % git_file)

  os.chdir (os.path.join (repo_path, "git"))
  if os.system ("git commit -a -F %s" % name) != 0:
    raise Exception ("git commit failed")
  return

status_line = StatusLine.StatusLine()
hash_cache = HashCache.HashCache()
command = None
command_func = None
arg_iter = sys.argv[1:].__iter__()
args = []

for arg in arg_iter:
  commands = [
    ( "commit",         cmd_commit, 1),
  ]
  parse_ok = False
  if command == None:
    for c in commands:
      if c[0] == arg:
        command_func = c[1]
        command_args = c[2]
        command = c[0]
        parse_ok = True
  else:
    if command_args > 0:
      args += [ arg ]
      parse_ok = True
  if not parse_ok:
    sys.stderr.write ("can't parse command line args...\n")
    sys.exit (1)

if command_func != None:
  try:
    command_func()
  except Exception, ex:
    print "\n\n"
    print "=================================================="
    traceback.print_exc()
    print "=================================================="
    print "\n\n"
    hash_cache.save()
    sys.stderr.write ("bfsync2: %s\n" % ex)
    sys.exit (1)
  hash_cache.save()
else:
  print "usage: bfsync <command> [ args... ]"
