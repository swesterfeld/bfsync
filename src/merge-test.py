#!/usr/bin/python

# bfsync: Big File synchronization tool

# Copyright (C) 2011 Stefan Westerfeld
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os
import sys
import time
import traceback
from bfsync.commitutils import commit
from bfsync.transferutils import get, push, pull
from bfsync.utils import connect_db
from bfsync.journal import run_commands

BFSYNC = os.path.join (os.getcwd(), "bfsync.py")
BFSYNCFS = os.path.join (os.getcwd(), "../fs/bfsyncfs")

tests = []

class Repo:
  def __init__ (self, path, merge_mode):
    self.path = path
    self.merge_mode = merge_mode

    # connect to db
    self.repo = connect_db (self.path)

  def run (self, cmd):
    old_cwd = os.getcwd()
    os.chdir (self.path)
    os.system (cmd)
    os.chdir (old_cwd)

  def runx (self, cmd):
    old_cwd = os.getcwd()
    os.chdir (self.path)
    if os.system (cmd) != 0:
      raise Exception ("Command %s failed" % cmd)
    os.chdir (old_cwd)

  def commit (self):
    old_cwd = os.getcwd()
    os.chdir (self.path)
    try:
      commit (self.repo, commit_args = { "message" : "autogenerated message", "author" : "no author" })
      run_commands (self.repo)
    except Exception, e:
      print "COMMIT FAILED: %s" % e
      sys.exit (1)
    os.chdir (old_cwd)

  def get (self):
    old_cwd = os.getcwd()
    os.chdir (self.repo.path)
    try:
      get (self.repo, [])
    except Exception, e:
      print "GET FAILED: %s" % e
      sys.exit (1)
    os.chdir (old_cwd)

  def push (self):
    old_cwd = os.getcwd()
    os.chdir (self.repo.path)
    try:
      push (self.repo, [])
    except Exception, e:
      print "PUSH FAILED: %s" % e
      sys.exit (1)
    os.chdir (old_cwd)

  def pull (self, args):
    old_cwd = os.getcwd()
    os.chdir (self.repo.path)
    pull (self.repo, args)
    run_commands (self.repo)
    os.chdir (old_cwd)

  def check_integrity (self):
    old_cwd = os.getcwd()
    os.chdir (self.repo.path)
    success = os.system ("%s debug-integrity >/dev/null" % BFSYNC) == 0
    if not success:
      print
      os.system ("%s debug-integrity" % BFSYNC) == 0
      print
    os.chdir (old_cwd)
    if not success:
      raise Exception ("db integrity check failed")

  def close (self):
    self.repo.conn.close()
    self.repo = None

def sync_repos (a, b):
  # send changes from a to master
  a.push()
  # merge changes from master into b; send merged result to master
  if b.merge_mode == "m":
    b.pull (["--always-master"])
  elif b.merge_mode == "l":
    b.pull (["--always-local"])
  elif b.merge_mode == "b":
    b.pull (["--always-both"])
  else:
    b.pull ([])           # interactive
  b.push()
  b.get()                 # get missing file contents
  # pull merged changes into repo a
  a.pull ([])
  a.get()                 # get missing file contents

def create_same (a, b):
  a.runx ("echo 'Hello Repo A' > x")
  a.commit()
  b.runx ("echo 'Hello Repo B' > x")
  b.commit()
  sync_repos (a, b)

tests += [
  ( create_same, "create-same", "independently create file with same name in repo a & b" )
]

def change_same (a, b):
  # create f on both repos
  a.runx ("echo 'common file' > f")
  a.commit()
  sync_repos (a, b)
  # edit f on both repos
  a.runx ("echo 'edit repo A' >> f")
  a.commit()
  b.runx ("echo 'edit repo B' >> f")
  b.commit()
  # merge
  sync_repos (a, b)
  print "#########################################################################"
  print "after merge:"
  print "#########################################################################"
  print "# REPO A:"
  a.runx ("cat f")
  print "# REPO B:"
  b.runx ("cat f")

tests += [
  ( change_same, "change-same", "edit contents of same file on repo a & b" )
]

def change2_same (a, b):
  # create f on both repos
  a.runx ("echo 'common file' > f")
  a.commit()
  sync_repos (a, b)
  # edit f on both repos
  a.runx ("echo 'edit repo A1' >> f")
  a.commit()
  a.runx ("echo 'edit repo A2' >> f")
  a.commit()
  b.runx ("echo 'edit repo B1' >> f")
  b.commit()
  b.runx ("echo 'edit repo B2' >> f")
  b.commit()
  # merge
  sync_repos (a, b)
  print "#########################################################################"
  print "after merge:"
  print "#########################################################################"
  print "# REPO A:"
  a.runx ("cat f")
  print "# REPO B:"
  b.runx ("cat f")

tests += [
  ( change2_same, "change2-same", "edit contents of same file on repo a & b, two edits for each repo" )
]

def create_indep (a, b):
  # create file-a in repo a
  a.runx ("echo 'new file a' > file-a")
  a.commit()
  # create file-b in repo b
  b.runx ("echo 'new file b' > file-b")
  b.commit()
  # merge
  sync_repos (a, b)
  print "#########################################################################"
  print "after merge:"
  print "#########################################################################"
  print "# REPO A:"
  a.runx ("ls -l")
  a.runx ("cat file-a")
  a.runx ("cat file-b")
  print "# root"
  a.runx ("stat .")
  print "# REPO B:"
  b.runx ("ls -l")
  b.runx ("cat file-a")
  b.runx ("cat file-b")
  print "# root"
  b.runx ("stat .")

tests += [
  ( create_indep, "create-indep", "create independent file-a in repo a and file-b in repo-b" )
]

def hardlink (a, b):
  # create f on both repos
  a.runx ("echo 'common file' > f")
  a.commit()
  sync_repos(a, b)

  # create hardlink in both repos
  a.runx ("ln f af")
  a.commit()
  b.runx ("ln f bf")
  b.commit()

  # merge
  sync_repos (a, b)
  print "#########################################################################"
  print "after merge:"
  print "#########################################################################"
  print "# REPO A:"
  a.run ("stat f af bf")
  print "# REPO B:"
  b.run ("stat f af bf")

tests += [
  ( hardlink, "hardlink", "create independent hardlinks on the same inode" )
]

def hardlink_rm (a, b):
  # create f on both repos
  a.runx ("echo 'common file' > f")
  a.runx ("ln f fxa")
  a.runx ("ln f fxb")
  a.commit()

  sync_repos (a, b)
  # remove one hardlink in both repos
  a.runx ("rm fxa")
  a.commit()
  b.runx ("rm fxb")
  b.commit()

  # merge
  sync_repos (a, b)
  print "#########################################################################"
  print "after merge:"
  print "#########################################################################"
  print "# REPO A:"
  a.runx ("stat f")
  print "# REPO B:"
  b.runx ("stat f")

tests += [
  ( hardlink_rm, "hardlink-rm", "delete independent hardlinks on the same inode" )
]

def rm_change (x, y, a, b):
  # create f on both repos
  x.runx ("echo 'common file' > f")
  x.commit()
  sync_repos (x, y)
  # update f in x
  x.runx ("echo 'updated file'  > f")
  x.commit()
  # rm f in y
  y.runx ("rm f")
  y.commit()
  # merge
  sync_repos (a, b)
  print "#########################################################################"
  print "after merge:"
  print "#########################################################################"
  print "# REPO A:"
  a.run ("cat f")
  print "# REPO B:"
  b.run ("cat f")

def rm_change_a (a, b):
  rm_change (a, b, a, b)

tests += [
  ( rm_change_a, "rm-change-a", "change content of file in repo a while deleting it in repo b" )
]

def rm_change_b (a, b):
  rm_change (b, a, a, b)

tests += [
  ( rm_change_b, "rm-change-b", "change content of file in repo b while deleting it in repo a" )
]

def attr_change (a, b):
  a.runx ("echo 'common file' > f")
  a.commit()
  sync_repos (a, b)
  # change attributes
  a.run ("chmod 600 f")
  a.commit()
  b.runx ("touch f")
  b.commit()
  # merge
  sync_repos (a, b)
  print "#########################################################################"
  print "after merge:"
  print "#########################################################################"
  print "# REPO A:"
  a.runx ("stat f")
  print "# REPO B:"
  b.runx ("stat f")
  if a.merge_mode == "m":
    if (os.stat ("a/f").st_mode & 0777) != 0600:
      raise Exception ("mode != 0600")
  if a.merge_mode == "l":
    if (os.stat ("a/f").st_mode & 0777) == 0600:
      raise Exception ("mode == 0600")

tests += [
  ( attr_change, "attr-change", "change attributes of file in repo a & b" )
]

def rm_combine (a, b):
  # create f and g on both repos
  a.runx ("echo 'common file' > f")
  a.runx ("ln f g")
  a.commit()
  sync_repos (a, b)
  # remove one hardlink in repo a...
  a.runx ("rm f")
  a.commit()
  # ... and the other in repo b
  b.runx ("rm g")
  b.commit()
  # merge
  sync_repos (a, b)
  print "#########################################################################"
  print "after merge:"
  print "#########################################################################"
  print "# REPO A:"
  a.run ("cat f")
  a.run ("cat g")
  print "# REPO B:"
  b.run ("cat f")
  b.run ("cat g")

tests += [
  ( rm_combine, "rm-combine", "rm links in repo a & b so that the combination removes the inode")
]

def rm_same (a, b):
  # create f in both repos
  a.runx ("echo 'common file' > f")
  a.commit()
  sync_repos (a, b)
  # remove f in repo a...
  a.runx ("rm f")
  a.commit()
  # ... and in repo b
  b.runx ("rm f")
  b.commit()
  # merge
  sync_repos (a, b)
  print "#########################################################################"
  print "after merge:"
  print "#########################################################################"
  print "# REPO A:"
  a.run ("cat f")
  print "# REPO B:"
  b.run ("cat f")

tests += [
  ( rm_same, "rm-same", "rm same file independently in repo a & b")
]

def link_coll (a, b):
  # create f in both repos
  a.runx ("echo 'file f' > f")
  a.runx ("echo 'file g' > g")
  a.commit()
  sync_repos (a, b)
  # link f to x in repo a...
  a.runx ("ln f x")
  a.commit()
  # ... and g to x repo b
  b.runx ("ln g x")
  b.commit()
  # merge
  sync_repos (a, b)
  print "#########################################################################"
  print "after merge:"
  print "#########################################################################"
  print "# REPO A:"
  a.runx ("ls -l")
  a.runx ("cat x")
  print "# REPO B:"
  b.runx ("ls -l")
  b.runx ("cat x")

tests += [
  ( link_coll, "link-coll", "create hardlink to x with different target in both repos")
]

def mv_mv (a, b):
  # create f in both repos
  a.runx ("echo 'file f' > f")
  a.commit()
  sync_repos (a, b)
  # rename f to f-a in repo a...
  a.runx ("mv f f-a")
  a.commit()
  # ... and rename f to f-b repo b
  b.runx ("mv f f-b")
  b.commit()
  # merge
  sync_repos (a, b)
  print "#########################################################################"
  print "after merge:"
  print "#########################################################################"
  print "# REPO A:"
  a.runx ("ls -l")
  a.run ("cat f-a")
  a.run ("cat f-b")
  print "# REPO B:"
  a.runx ("ls -l")
  a.run ("cat f-a")
  a.run ("cat f-b")
  if a.merge_mode == "m":
    if not os.path.exists ("a/f-a"):
      raise Exception ("missing file f-a")
    if os.path.exists ("a/f-b"):
      raise Exception ("a/f-b shouldn't be there")
    if os.path.exists ("a/f"):
      raise Exception ("a/f shouldn't be there")
  if a.merge_mode == "l":
    if not os.path.exists ("a/f-b"):
      raise Exception ("missing file f-b")
    if os.path.exists ("a/f-a"):
      raise Exception ("a/f-a shouldn't be there")
    if os.path.exists ("a/f"):
      raise Exception ("a/f shouldn't be there")

tests += [
  ( mv_mv, "mv-mv", "rename common file to two different names")
]

def mv2dir (a, b):
  # create f in both repos
  a.runx ("echo 'file f' > f")
  a.commit()
  sync_repos (a, b)
  # move to subdir in repo a
  a.runx ("mkdir -p d/subdir")
  a.runx ("mv f d/subdir")
  a.commit()
  # move to subdir in repo b
  b.runx ("mkdir dir")
  b.runx ("mv f dir")
  b.commit()
  sync_repos (a, b)
  print "#########################################################################"
  print "after merge:"
  print "#########################################################################"
  print "# REPO A:"
  a.runx ("ls -l dir")
  a.runx ("ls d/subdir")
  print "# REPO B:"
  b.runx ("ls -l dir")
  b.runx ("ls d/subdir")

tests += [
  ( mv2dir, "mv2dir", "move common file into two different subdirs")
]

def dir_dir_mv (a, b):
  # create f in both repos
  a.runx ("mkdir -p dir1/sub1 dir1/sub2 dir2/sub1")
  a.runx ("echo 'file f' > dir1/sub1/f")
  a.commit()
  sync_repos (a, b)
  # move to subdir in repo a
  a.runx ("mv dir1/sub1/f dir1/sub2/f")
  a.commit()
  # move to subdir in repo b
  b.runx ("mv dir1/sub1/f dir2/sub1/f")
  b.commit()
  sync_repos (a, b)
  print "#########################################################################"
  print "after merge:"
  print "#########################################################################"
  print "# REPO A:"
  a.runx ("""find . \( -name '.bfsync' -prune \) -o -type f -print""")
  print "# REPO B:"
  b.runx ("""find . \( -name '.bfsync' -prune \) -o -type f -print""")

tests += [
  ( dir_dir_mv, "dir-dir-mv", "move common file from subdir to subdir")
]

def relink (a, b):
  # create f, g, h in both repos
  a.runx ("echo 'file f' > f")
  a.runx ("echo 'file g' > g")
  a.runx ("echo 'file h' > h")
  a.commit()
  sync_repos (a, b)
  a.runx ("mv g f")
  a.commit()
  b.runx ("mv h f")
  b.commit()
  sync_repos (a, b)
  print "#########################################################################"
  print "after merge:"
  print "#########################################################################"
  print "# REPO A:"
  a.runx ("ls -l")
  a.runx ("cat f")
  print "# REPO B:"
  b.runx ("ls -l")
  b.runx ("cat f")

tests += [
  ( relink, "relink", "relink f to either g or h")
]

def link_rewrite_rm (a, b):
  a.runx ("echo 'file x created in a' > x")
  a.commit()
  b.runx ("echo 'file x created in b' > x")
  b.commit()
  b.runx ("rm x")
  b.commit()
  a.push()    # ensure that a is the version in the master history
  sync_repos (a, b)
  print "#########################################################################"
  print "after merge:"
  print "#########################################################################"
  print "# REPO A:"
  a.run ("ls -l")
  print "# REPO B:"
  b.run ("ls -l")

tests += [
  ( link_rewrite_rm, "link-rewrite-rm", "delete link that needed link rewriting")
]

def mv3 (a, b):
  a.runx ("echo 'file x created in a' > x")
  a.commit()
  sync_repos (a, b)

  b.runx ("ln x lb")
  b.commit()
  b.runx ("mv x bx1")
  b.commit()
  b.runx ("mv bx1 bx2")
  b.commit()

  a.runx ("ln x la")
  a.commit()
  a.runx ("mv x ax1")
  a.commit()
  a.runx ("mv ax1 ax2")
  a.commit()
  a.push()    # ensure that a is the version in the master history
  sync_repos (a, b)
  print "#########################################################################"
  print "after merge:"
  print "#########################################################################"
  print "# REPO A:"
  a.run ("ls -l")
  a.run ("stat ax2 bx2 la lb")
  print "# REPO B:"
  b.run ("ls -l")

tests += [
  ( mv3, "mv3", "multiple renames for the same file")
]

def subdir_rm (a, b):
  a.runx ("mkdir dir")
  a.commit()
  sync_repos (a, b)

  b.runx ("echo data > dir/data")
  b.commit()
  a.runx ("rm -rf dir")
  a.commit()

  a.push()    # ensure that a is the version in the master history
  sync_repos (a, b)
  print "#########################################################################"
  print "after merge:"
  print "#########################################################################"
  print "# REPO A:"
  a.run ("ls -l")
  print "# REPO B:"
  b.run ("ls -l")

tests += [
  ( subdir_rm, "subdir-rm", "change a file that exists in a subdir; rm -rf subdir")
]

def subdir_rm2 (a, b):
  a.runx ("mkdir dir")
  a.commit()
  sync_repos (a, b)

  b.runx ("echo data > dir/data")
  b.commit()
  b.runx ("mv dir/data dir/new_data")
  b.commit()
  a.runx ("rm -rf dir")
  a.commit()

  a.push()    # ensure that a is the version in the master history
  sync_repos (a, b)
  print "#########################################################################"
  print "after merge:"
  print "#########################################################################"
  print "# REPO A:"
  a.run ("ls -l")
  print "# REPO B:"
  b.run ("ls -l")

tests += [
  ( subdir_rm2, "subdir-rm2", "change/mv a file that exists in a subdir; rm -rf subdir")
]

def subdir_change (a, b):
  a.runx ("mkdir dir")
  a.runx ("echo 'common file' > dir/f")
  a.commit()
  sync_repos (a, b)

  b.runx ("echo 'file B' >> dir/f")
  b.commit()
  a.runx ("echo 'file A' >> dir/f")
  a.commit()

  a.push()    # ensure that a is the version in the master history
  sync_repos (a, b)
  print "#########################################################################"
  print "after merge:"
  print "#########################################################################"
  print "# REPO A:"
  a.run ("ls -l")
  a.run ("cat dir/f")
  print "# REPO B:"
  b.run ("ls -l")
  b.run ("cat dir/f")

tests += [
  ( subdir_change, "subdir-change", "change subdir file contents in repo a/b")
]

def setup_initial():
  if os.path.exists ("merge-test"):
    os.system ("rm -rf merge-test")

  os.mkdir ("merge-test")
  os.chdir ("merge-test")
  os.system ("%s init master" % BFSYNC)
  os.system ("%s clone master repo-a" % BFSYNC)
  os.system ("%s clone master repo-b" % BFSYNC)
  os.system ("""echo 'default { get "'$PWD/repo-b'"; }' >> repo-a/config""")
  os.system ("""echo 'default { get "'$PWD/repo-a'"; }' >> repo-b/config""")
  os.system ("""echo 'default { put "'$PWD/repo-b'"; }' >> repo-a/config""")
  os.system ("""echo 'default { put "'$PWD/repo-a'"; }' >> repo-b/config""")
  os.mkdir ("a")
  os.mkdir ("b")
  os.system ("rsync -a master repo-a repo-b backup")

def start_bfsyncfs (a_or_b):
  if os.system ("""( echo "*** fs start (`date`)"; %s -f repo-%s %s; echo "*** fs stop (`date`), exit $?"
                   ) >> mtfs.log 2>&1 &""" % (BFSYNCFS, a_or_b, a_or_b)) != 0:
    raise Exception ("can't start bfsyncfs")
  while not os.path.exists ("%s/.bfsync/info" % a_or_b):
    time.sleep (0.1)

def setup():
  os.system ("fusermount -u merge-test/a")
  os.system ("fusermount -u merge-test/b")

  if not os.path.exists ("merge-test/backup"):
    setup_initial()
  else:
    os.chdir ("merge-test")

  # rsync'ing the repo data is faster than creating it from scratch
  os.system ("rsync -a --delete backup/* .")

  start_bfsyncfs ("a")
  start_bfsyncfs ("b")

def main():
  if len (sys.argv) == 2:
    if sys.argv[1] == "setup":
      setup()
    elif sys.argv[1] == "all":
      old_cwd = os.getcwd()
      results = []
      for t in tests:
        for merge_mode in [ "m", "l", "b" ]:
          setup()
          a = Repo ("a", merge_mode)
          b = Repo ("b", merge_mode)
          print "==================================================================="
          print "Running test: %s\n -> %s" % (t[1], t[2])
          print "==================================================================="
          try:
            t[0] (a, b)
            a.check_integrity()
            b.check_integrity()
          except Exception, e:
            results += [ (t[1] + " / merge=%s" % merge_mode, "FAIL", "%s" % e) ]

            if False:  # print stacktrace for FAIL
              sys.stderr.write ("\n\n\n")
              sys.stderr.write ("==================================================\n")
              traceback.print_exc()
              sys.stderr.write ("==================================================\n")
              sys.stderr.write ("\n\n\n")
              sys.exit (1)
          else:
            results += [ (t[1] + " / merge=%s" % merge_mode, "OK") ]
          a.close()
          b.close()
          os.chdir (old_cwd)

      print "==================================================================="
      for result in results:
        print "%30s   %s" % (result[0], result[1])
        if len (result) > 2:
          print "  <=>  %s" % result[2]
    else:
      setup()
      a = Repo ("a", None)
      b = Repo ("b", None)
      for t in tests:
        if sys.argv[1] == t[1]:
          print "==================================================================="
          print "Running test: %s\n -> %s" % (t[1], t[2])
          print "==================================================================="
          t[0] (a, b)
          a.check_integrity()
          b.check_integrity()
    sys.exit (0)
  print
  print "Supported merge tests:"
  for t in tests:
    print " - %-13s -> %s" % (t[1], t[2])

  print " - %-13s -> %s" % ("all", "run all tests")
  print " - %-13s -> %s" % ("setup", "only setup repos a & b for merge tests")

if False: # profiling
  import cProfile

  cProfile.run ("main()", "/tmp/bfsync-profile-merge-test")
else:
  main()
